<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/customSocket/mySocket.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/customSocket/mySocket.py" />
              <option name="originalContent" value="# my_socket.py&#10;import ipaddress&#10;import queue&#10;import sys&#10;import threading&#10;import time&#10;from queue import Queue&#10;from queue import SimpleQueue&#10;&#10;&#10;&#10;from socket import socket, AF_INET, SOCK_DGRAM&#10;from typing import Tuple&#10;&#10;from customSocket.helpers.ack_store import AckStore&#10;from customSocket.helpers.file_store import FileStore&#10;from customSocket.helpers.noack_store import NoAckStore&#10;from customSocket.recv_handlers import personal_recv_handler&#10;from customSocket.routing.neigbor_table import NextNeighborTable&#10;from customSocket.routing.neighbor_monitor import NeighborMonitor&#10;from customSocket.routing.routing_table import RoutingTable&#10;from customSocket.routing.routing_table_monitor import RoutingTableMonitor&#10;from customSocket.send_handlers import msg_handler, file_handler, ack_handler, no_ack_handler, heartbeat_handler, \&#10;    hello_handler, routing_update_handler&#10;from . import byteDecoder, config&#10;&#10;&#10;class MySocket:&#10;&#10;    # ====================================================================================================&#10;    # Constructor&#10;    # ====================================================================================================&#10;&#10;    def __init__(self, my_ip_str, my_port):&#10;        self.my_ip_str = my_ip_str&#10;        self.my_port = my_port&#10;&#10;        self.my_ip_bytes = int(ipaddress.IPv4Address(my_ip_str)).to_bytes(4, &quot;big&quot;)&#10;        self.my_port_bytes = my_port.to_bytes(2, &quot;big&quot;)&#10;&#10;        self.sock = socket(AF_INET, SOCK_DGRAM)&#10;        self.sock.bind((host, port))&#10;        print(f&quot;\n[INFO] Listening on {my_ip_str}:{my_port}\n&quot;)&#10;        #self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 4 * 1024 * 1024)&#10;&#10;        # self.send_queue = Queue() #OLD&#10;        self.send_queue = SimpleQueue()&#10;&#10;        # queues for all incomming msgs&#10;        self.all_incoming = queue.Queue(maxsize=20000)&#10;        self.routing_incoming = queue.Queue(maxsize=10000)&#10;        self.my_incoming = queue.Queue(maxsize=10000)&#10;&#10;        # storage for acks and noacks&#10;        self.ack_store = AckStore()&#10;        self.noack_store = NoAckStore()&#10;&#10;        # storage for all files that the user receives&#10;        self.file_store = FileStore(&#10;            on_frame_complete=self.send_ack_frame,  #Callback function&#10;            on_frame_timeout=self.send_noack_frame  #Callback function&#10;        )&#10;&#10;        # Sequence Number Producer&#10;        self.seq_counter = 1&#10;        self.seq_lock = threading.Lock()&#10;        self.takenSeqNum = set()&#10;&#10;        # Routing Logic&#10;        self.routing_table = RoutingTable()&#10;        self.neighbor_table = NextNeighborTable()&#10;&#10;        # Hello Logic - After giving Hello IP/Ports Code, socket will run&#10;        self.hello_list = self.handel_hello()&#10;&#10;        # Garbage Collector and File Assembler&#10;&#10;        # Neighbor Monitoring Thread starten&#10;        neighbor_monitor = NeighborMonitor(&#10;            self.neighbor_table,&#10;            self.routing_table,&#10;            on_routing_update=self.send_routing_update,  #Callback function&#10;        )&#10;        neighbor_monitor.start()&#10;&#10;        # Routing Table Monitor starten (überwacht poisoned routes)&#10;        routing_monitor = RoutingTableMonitor(&#10;            self.routing_table,&#10;            on_routing_update=self.send_routing_update  #Callback function&#10;        )&#10;        routing_monitor.start()&#10;&#10;        # Heartbeat starten&#10;        heartbeat = threading.Thread(target=self.send_heartbeats, daemon=True)&#10;        heartbeat.start()&#10;&#10;        # Listener Thread starten&#10;        threading.Thread(target=self.listen, daemon=True).start()&#10;&#10;        # Incoming Handler starten&#10;        threading.Thread(target=self.handel_incoming, daemon=True).start()&#10;        threading.Thread(target=self.handel_my_incoming, daemon=True).start()&#10;        threading.Thread(target=self.handel_routing_incoming, daemon=True).start()&#10;&#10;        # Send Loop Threads starten&#10;        for _ in range(5):&#10;            threading.Thread(target=self.send_loop, daemon=True).start()&#10;&#10;        # Sender Thread starten&#10;        send_thread = threading.Thread(target=self.send_message, daemon=True)&#10;        send_thread.start()&#10;&#10;        while True:&#10;            pass&#10;&#10;    # ====================================================================================================&#10;    # Listening and Routing&#10;    # ====================================================================================================&#10;&#10;    def listen(self):&#10;&#10;        while True:&#10;            try:&#10;                data, addr = self.sock.recvfrom(8096)&#10;                self.all_incoming.put(data)&#10;            except Exception as e:&#10;                print(e)&#10;&#10;&#10;    # -------- Handels all incoming data and structures --------------&#10;    def handel_incoming(self):&#10;        queue_get = self.all_incoming.get&#10;        while True:&#10;            data = queue_get()&#10;            if data[5: 9] == self.my_ip_bytes and data[13: 15] == self.my_port_bytes:&#10;                self.my_incoming.put(data)&#10;            else:&#10;                self.routing_incoming.put(data)&#10;&#10;    # ---------- Handels data that is adressed to you ------------------&#10;    HANDLERS = {&#10;        1: personal_recv_handler.handle_ack,&#10;        2: personal_recv_handler.handle_no_ack,&#10;        3: personal_recv_handler.handle_hello,&#10;        4: personal_recv_handler.handle_goodbye,&#10;        5: personal_recv_handler.handle_msg,&#10;        6: personal_recv_handler.handle_file_chunk,&#10;        7: personal_recv_handler.handle_file_info,&#10;        8: personal_recv_handler.handle_heartbeat,&#10;        9: personal_recv_handler.handle_routing_update,&#10;    }&#10;    def handel_my_incoming(self):&#10;        queue_get = self.my_incoming.get&#10;        while True:&#10;            data = queue_get()&#10;            msgType = int.from_bytes(data[0:1], &quot;big&quot;)&#10;            self.HANDLERS[msgType](self, data, on_routing_update=self.send_routing_update)&#10;&#10;    # ---------- Handels data which is not for you and needs routing ---&#10;    def handel_routing_incoming(self):&#10;        routing_update_handler.send_routing_update(self)&#10;        #TODO Handel routing mechanics -- Depends on the existence of Routing Tables etc&#10;        print(&quot;Routing&quot;)&#10;&#10;    # ---------- Handels ACK and NOACK of data sent to you -&#10;&#10;    def send_ack_frame(self, seq_num, src_ip, src_port):&#10;        ack_handler.send_ack(self, seq_num, src_ip, src_port, self.my_ip_str, self.my_port)&#10;&#10;    def send_noack_frame(self, key, missing_chunks):&#10;        seq_num, src_ip, src_port = key&#10;        print(f&quot;[NOACK] missing {missing_chunks}&quot;)&#10;        no_ack_handler.send_no_ack(self, seq_num, src_ip, src_port, self.my_ip_str, self.my_port, missing_chunks)&#10;&#10;    # --------- Handel routing/neigbor Updates ----------------------------------&#10;    def send_routing_update(self):&#10;        print(&quot;[INFO] Routing Update triggered!&quot;)&#10;        # → hier baust du ROUTING_UPDATE und sendest an alle alive neighbors&#10;&#10;    # --------- Send heartbeats ----------------------------------&#10;    def send_heartbeats(self):&#10;        while True:&#10;            neighbors = self.neighbor_table.get_alive_neighbors()&#10;            seqNum = self.get_seq_num()&#10;            for entry in neighbors:&#10;                heartbeat_handler.send_heartbeat(self, seqNum, entry.ip, entry.port, self.my_ip_str, self.my_port)&#10;            #print(f&quot;\n[SENT]Heartbeats to: {neighbors}\n&quot;)&#10;            time.sleep(config.HEARTBEAT_TIMER)&#10;&#10;    # ====================================================================================================&#10;    # Sending Hello and Goodbye&#10;    # ====================================================================================================&#10;&#10;    def handel_hello(self):&#10;        neighbors = []&#10;        entry: Tuple[str, int]&#10;        print(&quot;\nBitte gib im folgenden jeweils die IP und den Port der Nachbar ein die du hinzufügen willst.\nEine leere Eingabe beendet das hinzufügen.\n&quot;)&#10;        while True:&#10;            entry_ip = input(&quot;\nGib die IP eines Nachbarns ein:&quot;)&#10;            if not entry_ip: break&#10;            entry_port = input(&quot;\nGib die den Port des Nachbarns ein:&quot;)&#10;            if not entry_port: break&#10;            neighbors.append((entry_ip, entry_port))&#10;&#10;        for entry in neighbors:&#10;            dest_ip, dest_port = entry&#10;            hello_handler.send_hello(self, self.get_seq_num(), dest_ip, int(dest_port), self.my_ip_str, self.my_port)&#10;        return&#10;&#10;    # ====================================================================================================&#10;    # Sending MSG and DATA&#10;    # ====================================================================================================&#10;&#10;    def send_message(self):&#10;&#10;        while True:&#10;            try:&#10;                dest_ip = input(&quot;\nZiel-IP: &quot;)&#10;                dest_port = int(input(&quot;\nZiel-Port: &quot;))&#10;                msg = input(&quot;\nGib deine Nachricht ein (Wenn du eine Datei verschicken willst, gib \&quot;Send Data\&quot; ein): &quot;)&#10;                seqNum = self.get_seq_num()&#10;                if msg.upper() == &quot;SEND DATA&quot;:&#10;                    threading.Thread(target=file_handler.send_Data, args=(self, seqNum, msg, dest_ip, dest_port, self.my_ip_str, self.my_port), daemon=True).start()&#10;                else:&#10;                    threading.Thread(target=msg_handler.send_Text, args=(self, seqNum, msg, dest_ip, dest_port, self.my_ip_str, self.my_port), daemon=True).start()&#10;            except Exception as e:&#10;                print(e)&#10;            time.sleep(3)&#10;&#10;    # ----------- Set Sequence Number ------------&#10;    def get_seq_num(self):&#10;        with self.seq_lock:&#10;            num = self.seq_counter&#10;            self.seq_counter += 1&#10;            self.takenSeqNum.add(num)&#10;            return num&#10;&#10;    # ----------- Sending Loop waits for items in the queue, continouisly checks if the queue has data to send&#10;    def send_loop(self):&#10;        send = self.sock.sendto&#10;        queue_get = self.send_queue.get&#10;&#10;        while True:&#10;            #print(self.send_queue.qsize())&#10;            packet, addr = queue_get()&#10;            send(packet, addr)&#10;&#10;    # ====================================================================================================&#10;    # Starter&#10;    # ====================================================================================================&#10;if __name__ == &quot;__main__&quot;:&#10;    host = sys.argv[1]&#10;    port = int(sys.argv[2])&#10;    MySocket(host, port)" />
              <option name="updatedContent" value="# my_socket.py&#10;import ipaddress&#10;import queue&#10;import sys&#10;import threading&#10;import time&#10;from queue import Queue&#10;from queue import SimpleQueue&#10;&#10;&#10;&#10;from socket import socket, AF_INET, SOCK_DGRAM&#10;from typing import Tuple&#10;&#10;from customSocket.helpers.ack_store import AckStore&#10;from customSocket.helpers.file_store import FileStore&#10;from customSocket.helpers.noack_store import NoAckStore&#10;from customSocket.recv_handlers import personal_recv_handler&#10;from customSocket.routing.neigbor_table import NextNeighborTable&#10;from customSocket.routing.neighbor_monitor import NeighborMonitor&#10;from customSocket.routing.routing_table import RoutingTable&#10;from customSocket.routing.routing_table_monitor import RoutingTableMonitor&#10;from customSocket.send_handlers import msg_handler, file_handler, ack_handler, no_ack_handler, heartbeat_handler, \&#10;    hello_handler, routing_update_handler&#10;from . import byteDecoder, config&#10;&#10;&#10;class MySocket:&#10;&#10;    # ====================================================================================================&#10;    # Constructor&#10;    # ====================================================================================================&#10;&#10;    def __init__(self, my_ip_str, my_port):&#10;        self.my_ip_str = my_ip_str&#10;        self.my_port = my_port&#10;&#10;        self.my_ip_bytes = int(ipaddress.IPv4Address(my_ip_str)).to_bytes(4, &quot;big&quot;)&#10;        self.my_port_bytes = my_port.to_bytes(2, &quot;big&quot;)&#10;&#10;        self.sock = socket(AF_INET, SOCK_DGRAM)&#10;        self.sock.bind((host, port))&#10;        print(f&quot;\n[INFO] Listening on {my_ip_str}:{my_port}\n&quot;)&#10;        #self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 4 * 1024 * 1024)&#10;&#10;        # self.send_queue = Queue() #OLD&#10;        self.send_queue = SimpleQueue()&#10;&#10;        # queues for all incomming msgs&#10;        self.all_incoming = queue.Queue(maxsize=20000)&#10;        self.routing_incoming = queue.Queue(maxsize=10000)&#10;        self.my_incoming = queue.Queue(maxsize=10000)&#10;&#10;        # storage for acks and noacks&#10;        self.ack_store = AckStore()&#10;        self.noack_store = NoAckStore()&#10;&#10;        # storage for all files that the user receives&#10;        self.file_store = FileStore(&#10;            on_frame_complete=self.send_ack_frame,  #Callback function&#10;            on_frame_timeout=self.send_noack_frame  #Callback function&#10;        )&#10;&#10;        # Sequence Number Producer&#10;        self.seq_counter = 1&#10;        self.seq_lock = threading.Lock()&#10;        self.takenSeqNum = set()&#10;&#10;        # Routing Logic&#10;        self.routing_table = RoutingTable()&#10;        self.neighbor_table = NextNeighborTable()&#10;&#10;        # Hello Logic - After giving Hello IP/Ports Code, socket will run&#10;        self.hello_list = self.handel_hello()&#10;&#10;        # Garbage Collector and File Assembler&#10;&#10;        # Neighbor Monitoring Thread starten&#10;        neighbor_monitor = NeighborMonitor(&#10;            self.neighbor_table,&#10;            self.routing_table,&#10;            on_routing_update=self.send_routing_update,  #Callback function&#10;        )&#10;        neighbor_monitor.start()&#10;&#10;        # Routing Table Monitor starten (überwacht poisoned routes)&#10;        routing_monitor = RoutingTableMonitor(&#10;            self.routing_table,&#10;            on_routing_update=self.send_routing_update  #Callback function&#10;        )&#10;        routing_monitor.start()&#10;&#10;        # Heartbeat starten&#10;        heartbeat = threading.Thread(target=self.send_heartbeats, daemon=True)&#10;        heartbeat.start()&#10;&#10;        # Listener Thread starten&#10;        threading.Thread(target=self.listen, daemon=True).start()&#10;&#10;        # Incoming Handler starten&#10;        threading.Thread(target=self.handel_incoming, daemon=True).start()&#10;        threading.Thread(target=self.handel_my_incoming, daemon=True).start()&#10;        threading.Thread(target=self.handel_routing_incoming, daemon=True).start()&#10;&#10;        # Send Loop Threads starten&#10;        for _ in range(5):&#10;            threading.Thread(target=self.send_loop, daemon=True).start()&#10;&#10;        # Sender Thread starten&#10;        send_thread = threading.Thread(target=self.send_message, daemon=True)&#10;        send_thread.start()&#10;&#10;        while True:&#10;            pass&#10;&#10;    # ====================================================================================================&#10;    # Listening and Routing&#10;    # ====================================================================================================&#10;&#10;    def listen(self):&#10;&#10;        while True:&#10;            try:&#10;                data, addr = self.sock.recvfrom(8096)&#10;                self.all_incoming.put(data)&#10;            except Exception as e:&#10;                print(e)&#10;&#10;&#10;    # -------- Handels all incoming data and structures --------------&#10;    def handel_incoming(self):&#10;        queue_get = self.all_incoming.get&#10;        while True:&#10;            data = queue_get()&#10;            if data[5: 9] == self.my_ip_bytes and data[13: 15] == self.my_port_bytes:&#10;                self.my_incoming.put(data)&#10;            else:&#10;                self.routing_incoming.put(data)&#10;&#10;    # ---------- Handels data that is adressed to you ------------------&#10;    HANDLERS = {&#10;        1: personal_recv_handler.handle_ack,&#10;        2: personal_recv_handler.handle_no_ack,&#10;        3: personal_recv_handler.handle_hello,&#10;        4: personal_recv_handler.handle_goodbye,&#10;        5: personal_recv_handler.handle_msg,&#10;        6: personal_recv_handler.handle_file_chunk,&#10;        7: personal_recv_handler.handle_file_info,&#10;        8: personal_recv_handler.handle_heartbeat,&#10;        9: personal_recv_handler.handle_routing_update,&#10;    }&#10;    def handel_my_incoming(self):&#10;        queue_get = self.my_incoming.get&#10;        while True:&#10;            data = queue_get()&#10;            msgType = int.from_bytes(data[0:1], &quot;big&quot;)&#10;            self.HANDLERS[msgType](self, data, on_routing_update=self.send_routing_update)&#10;&#10;    # ---------- Handels data which is not for you and needs routing ---&#10;    def handel_routing_incoming(self):&#10;        routing_update_handler.send_routing_update(self)&#10;        #TODO Handel routing mechanics -- Depends on the existence of Routing Tables etc&#10;        print(&quot;Routing&quot;)&#10;&#10;    # ---------- Handels ACK and NOACK of data sent to you -&#10;&#10;    def send_ack_frame(self, seq_num, src_ip, src_port):&#10;        ack_handler.send_ack(self, seq_num, src_ip, src_port, self.my_ip_str, self.my_port)&#10;&#10;    def send_noack_frame(self, key, missing_chunks):&#10;        seq_num, src_ip, src_port = key&#10;        print(f&quot;[NOACK] missing {missing_chunks}&quot;)&#10;        no_ack_handler.send_no_ack(self, seq_num, src_ip, src_port, self.my_ip_str, self.my_port, missing_chunks)&#10;&#10;    # --------- Handel routing/neigbor Updates ----------------------------------&#10;    def send_routing_update(self):&#10;        print(&quot;[INFO] Routing Update triggered!&quot;)&#10;        # → hier baust du ROUTING_UPDATE und sendest an alle alive neighbors&#10;&#10;    # --------- Send heartbeats ----------------------------------&#10;    def send_heartbeats(self):&#10;        while True:&#10;            neighbors = self.neighbor_table.get_alive_neighbors()&#10;            seqNum = self.get_seq_num()&#10;            for entry in neighbors:&#10;                heartbeat_handler.send_heartbeat(self, seqNum, entry.ip, entry.port, self.my_ip_str, self.my_port)&#10;            #print(f&quot;\n[SENT]Heartbeats to: {neighbors}\n&quot;)&#10;            time.sleep(config.HEARTBEAT_TIMER)&#10;&#10;    # ====================================================================================================&#10;    # Sending Hello and Goodbye&#10;    # ====================================================================================================&#10;&#10;    def handel_hello(self):&#10;        neighbors = []&#10;        entry: Tuple[str, int]&#10;        print(&quot;\nBitte gib im folgenden jeweils die IP und den Port der Nachbar ein die du hinzufügen willst.\nEine leere Eingabe beendet das hinzufügen.\n&quot;)&#10;        while True:&#10;            entry_ip = input(&quot;\nGib die IP eines Nachbarns ein:&quot;)&#10;            if not entry_ip: break&#10;            entry_port = input(&quot;\nGib die den Port des Nachbarns ein:&quot;)&#10;            if not entry_port: break&#10;            neighbors.append((entry_ip, entry_port))&#10;&#10;        for entry in neighbors:&#10;            dest_ip, dest_port = entry&#10;            hello_handler.send_hello(self, self.get_seq_num(), dest_ip, int(dest_port), self.my_ip_str, self.my_port)&#10;        return&#10;&#10;    # ====================================================================================================&#10;    # Sending MSG and DATA&#10;    # ====================================================================================================&#10;&#10;    def send_message(self):&#10;&#10;        while True:&#10;            try:&#10;                dest_ip = input(&quot;\nZiel-IP: &quot;)&#10;                dest_port = int(input(&quot;\nZiel-Port: &quot;))&#10;                msg = input(&quot;\nGib deine Nachricht ein (Wenn du eine Datei verschicken willst, gib \&quot;Send Data\&quot; ein): &quot;)&#10;                seqNum = self.get_seq_num()&#10;                if msg.upper() == &quot;SEND DATA&quot;:&#10;                    threading.Thread(target=file_handler.send_Data, args=(self, seqNum, msg, dest_ip, dest_port, self.my_ip_str, self.my_port), daemon=True).start()&#10;                else:&#10;                    threading.Thread(target=msg_handler.send_Text, args=(self, seqNum, msg, dest_ip, dest_port, self.my_ip_str, self.my_port), daemon=True).start()&#10;            except Exception as e:&#10;                print(e)&#10;            time.sleep(3)&#10;&#10;    # ----------- Set Sequence Number ------------&#10;    def get_seq_num(self):&#10;        with self.seq_lock:&#10;            num = self.seq_counter&#10;            self.seq_counter += 1&#10;            self.takenSeqNum.add(num)&#10;            return num&#10;&#10;    # ----------- Sending Loop waits for items in the queue, continouisly checks if the queue has data to send&#10;    def send_loop(self):&#10;        send = self.sock.sendto&#10;        queue_get = self.send_queue.get&#10;&#10;        while True:&#10;            #print(self.send_queue.qsize())&#10;            packet, addr = queue_get()&#10;            send(packet, addr)&#10;&#10;    # ====================================================================================================&#10;    # Starter&#10;    # ====================================================================================================&#10;if __name__ == &quot;__main__&quot;:&#10;    host = sys.argv[1]&#10;    port = int(sys.argv[2])&#10;    MySocket(host, port)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/customSocket/recv_handlers/personal_recv_handler.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/customSocket/recv_handlers/personal_recv_handler.py" />
              <option name="originalContent" value="import ipaddress&#10;&#10;from customSocket import byteDecoder&#10;from customSocket.helpers.models import NoAckMessage&#10;from customSocket.send_handlers import ack_handler&#10;&#10;&#10;# =========================================================&#10;#&#10;# =========================================================&#10;def handle_ack(mySocket, data, on_routing_update=None):&#10;    mySocket.ack_store.add_ack(int.from_bytes(data[1: 5], &quot;big&quot;))&#10;    print(f&quot;\nRec Ack for Seq: {data[1: 5]}&quot;)&#10;&#10;# =========================================================&#10;#&#10;# =========================================================&#10;def handle_no_ack(mySocket, data, on_routing_update=None):&#10;    msg, succ = byteDecoder.decodePayload(data)&#10;    if not succ:&#10;        print(&quot;Received NoAck with Wrong Checksum&quot;)&#10;        return&#10;    pld = msg.payload&#10;    seq_num = pld.sequence_number&#10;    chunks = pld.missing_chunks&#10;    mySocket.noack_store.add_noack(seq_num, chunks)&#10;    print(f&quot;\nRec NOACK for Seq: {seq_num}, missing chunk: {chunks}\n&quot;)&#10;&#10;# =========================================================&#10;# Handling received HELLO&#10;# =========================================================&#10;def handle_hello(mySocket, data, on_routing_update):&#10;    src_ip = int.from_bytes(data[9: 13], &quot;big&quot;)&#10;    src_port = int.from_bytes(data[15: 17], &quot;big&quot;)&#10;    &#10;    # Füge Nachbarn zur Neighbor-Tabelle hinzu oder aktualisiere ihn&#10;    mySocket.neighbor_table.update_neighbor(src_ip, src_port)&#10;    &#10;    # Erstelle eine direkte Route zum Nachbarn (Distance = 1)&#10;    mySocket.routing_table.update_route(&#10;        dest_ip=src_ip,&#10;        dest_port=src_port,&#10;        next_hop_ip=src_ip,&#10;        next_hop_port=src_port,&#10;        distance=1&#10;    )&#10;    &#10;    # Triggere Routing Update an alle Nachbarn&#10;    on_routing_update()&#10;    print(f&quot;[HELLO] Received from {src_ip}:{src_port}&quot;)&#10;&#10;# =========================================================&#10;# Handling received MSGs&#10;# =========================================================&#10;&#10;def handle_msg(mySocket, data, on_routing_update=None):&#10;    msg, succ = byteDecoder.decodePayload(data)&#10;    if not succ:&#10;        print(&quot;Received Message with Wrong Checksum&quot;)&#10;        return&#10;    ack_handler.send_ack(mySocket, msg.header.sequence_number, msg.header.source_ip, msg.header.source_port, mySocket.my_ip_str, mySocket.my_port)&#10;    print(f&quot;\n[RECV from {msg.header.source_ip}:{msg.header.source_port}] \n&quot;&#10;          f&quot;{msg.payload.text}\n&quot;)&#10;# =========================================================&#10;# Handling received GOODBYE&#10;# =========================================================&#10;&#10;&#10;def handle_goodbye(mySocket, data, on_routing_update):&#10;    src_ip = int(ipaddress.IPv4Address(int.from_bytes(data[9: 13])))&#10;    src_port = int(ipaddress.IPv4Address(int.from_bytes(data[15: 17])))&#10;    mySocket.neighbor_table.kill_neighbor(src_ip, src_port)&#10;    on_routing_update()&#10;    print(&quot;handle_goodbye&quot;)&#10;&#10;# =========================================================&#10;#&#10;# =========================================================&#10;&#10;&#10;def handle_file_chunk(mySocket, data, on_routing_update=None):&#10;    file_chunk, succ = byteDecoder.decodePayload(data)&#10;    if not succ: return False&#10;    succ = mySocket.file_store.add_chunk(&#10;        file_chunk.header.sequence_number,&#10;        file_chunk.header.source_ip,&#10;        file_chunk.header.source_port,&#10;        file_chunk.header.chunk_id,&#10;        file_chunk.payload.data&#10;    )&#10;    print(f&quot;Got: {file_chunk.header.chunk_id}&quot;)&#10;    #print(&quot;handle_file_chunk&quot;)&#10;    return succ&#10;&#10;# =========================================================&#10;#&#10;# =========================================================&#10;&#10;&#10;def handle_file_info(mySocket, data, on_routing_update=None):&#10;    file_info, succ = byteDecoder.decodePayload(data)&#10;    if not succ: return False&#10;    succ = mySocket.file_store.register_file_info(&#10;        file_info.header.sequence_number,&#10;        file_info.header.source_ip,&#10;        file_info.header.source_port,&#10;        file_info.payload.filename,&#10;        file_info.header.chunk_length&#10;    )&#10;    print(f&quot;Got File Info {file_info.header.sequence_number} with total of {file_info.header.chunk_length} chunks&quot;)&#10;    return succ&#10;&#10;# =========================================================&#10;# Handling received HEARTBEAT&#10;# =========================================================&#10;&#10;&#10;def handle_heartbeat(mySocket, data, on_routing_update=None):&#10;    src_ip = int.from_bytes(data[9: 13], &quot;big&quot;)&#10;    src_port = int.from_bytes(data[15: 17], &quot;big&quot;)&#10;    mySocket.neighbor_table.update_neighbor(src_ip, src_port)&#10;    #print(f&quot;[HEARTBEAT] Received from {src_ip}:{src_port}&quot;)&#10;&#10;# =========================================================&#10;# Handling received ROUTING_UPDATE&#10;# =========================================================&#10;&#10;&#10;def handle_routing_update(mySocket, data, on_routing_update=None):&#10;    #TODO&#10;    print(&quot;handle_routing_update&quot;)&#10;" />
              <option name="updatedContent" value="import ipaddress&#10;&#10;from customSocket import byteDecoder&#10;from customSocket.helpers.models import NoAckMessage&#10;from customSocket.send_handlers import ack_handler&#10;&#10;&#10;# =========================================================&#10;#&#10;# =========================================================&#10;def handle_ack(mySocket, data, on_routing_update=None):&#10;    mySocket.ack_store.add_ack(int.from_bytes(data[1: 5], &quot;big&quot;))&#10;    print(f&quot;\nRec Ack for Seq: {data[1: 5]}&quot;)&#10;&#10;# =========================================================&#10;#&#10;# =========================================================&#10;def handle_no_ack(mySocket, data, on_routing_update=None):&#10;    msg, succ = byteDecoder.decodePayload(data)&#10;    if not succ:&#10;        print(&quot;Received NoAck with Wrong Checksum&quot;)&#10;        return&#10;    pld = msg.payload&#10;    seq_num = pld.sequence_number&#10;    chunks = pld.missing_chunks&#10;    mySocket.noack_store.add_noack(seq_num, chunks)&#10;    print(f&quot;\nRec NOACK for Seq: {seq_num}, missing chunk: {chunks}\n&quot;)&#10;&#10;# =========================================================&#10;# Handling received HELLO&#10;# =========================================================&#10;def handle_hello(mySocket, data, on_routing_update):&#10;    src_ip = int.from_bytes(data[9: 13], &quot;big&quot;)&#10;    src_port = int.from_bytes(data[15: 17], &quot;big&quot;)&#10;    &#10;    # Füge Nachbarn zur Neighbor-Tabelle hinzu oder aktualisiere ihn&#10;    mySocket.neighbor_table.update_neighbor(src_ip, src_port)&#10;    &#10;    # Erstelle eine direkte Route zum Nachbarn (Distance = 1)&#10;    mySocket.routing_table.update_route(&#10;        dest_ip=src_ip,&#10;        dest_port=src_port,&#10;        next_hop_ip=src_ip,&#10;        next_hop_port=src_port,&#10;        distance=1&#10;    )&#10;    &#10;    # Triggere Routing Update an alle Nachbarn&#10;    on_routing_update()&#10;    print(f&quot;[HELLO] Received from {src_ip}:{src_port}&quot;)&#10;&#10;# =========================================================&#10;# Handling received MSGs&#10;# =========================================================&#10;&#10;def handle_msg(mySocket, data, on_routing_update=None):&#10;    msg, succ = byteDecoder.decodePayload(data)&#10;    if not succ:&#10;        print(&quot;Received Message with Wrong Checksum&quot;)&#10;        return&#10;    ack_handler.send_ack(mySocket, msg.header.sequence_number, msg.header.source_ip, msg.header.source_port, mySocket.my_ip_str, mySocket.my_port)&#10;    print(f&quot;\n[RECV from {msg.header.source_ip}:{msg.header.source_port}] \n&quot;&#10;          f&quot;{msg.payload.text}\n&quot;)&#10;# =========================================================&#10;# Handling received GOODBYE&#10;# =========================================================&#10;&#10;&#10;def handle_goodbye(mySocket, data, on_routing_update):&#10;    src_ip = int(ipaddress.IPv4Address(int.from_bytes(data[9: 13])))&#10;    src_port = int(ipaddress.IPv4Address(int.from_bytes(data[15: 17])))&#10;    mySocket.neighbor_table.kill_neighbor(src_ip, src_port)&#10;    on_routing_update()&#10;    print(&quot;handle_goodbye&quot;)&#10;&#10;# =========================================================&#10;#&#10;# =========================================================&#10;&#10;&#10;def handle_file_chunk(mySocket, data, on_routing_update=None):&#10;    file_chunk, succ = byteDecoder.decodePayload(data)&#10;    if not succ: return False&#10;    succ = mySocket.file_store.add_chunk(&#10;        file_chunk.header.sequence_number,&#10;        file_chunk.header.source_ip,&#10;        file_chunk.header.source_port,&#10;        file_chunk.header.chunk_id,&#10;        file_chunk.payload.data&#10;    )&#10;    print(f&quot;Got: {file_chunk.header.chunk_id}&quot;)&#10;    #print(&quot;handle_file_chunk&quot;)&#10;    return succ&#10;&#10;# =========================================================&#10;#&#10;# =========================================================&#10;&#10;&#10;def handle_file_info(mySocket, data, on_routing_update=None):&#10;    file_info, succ = byteDecoder.decodePayload(data)&#10;    if not succ: return False&#10;    succ = mySocket.file_store.register_file_info(&#10;        file_info.header.sequence_number,&#10;        file_info.header.source_ip,&#10;        file_info.header.source_port,&#10;        file_info.payload.filename,&#10;        file_info.header.chunk_length&#10;    )&#10;    print(f&quot;Got File Info {file_info.header.sequence_number} with total of {file_info.header.chunk_length} chunks&quot;)&#10;    return succ&#10;&#10;# =========================================================&#10;# Handling received HEARTBEAT&#10;# =========================================================&#10;&#10;&#10;def handle_heartbeat(mySocket, data, on_routing_update=None):&#10;    src_ip = int.from_bytes(data[9: 13], &quot;big&quot;)&#10;    src_port = int.from_bytes(data[15: 17], &quot;big&quot;)&#10;    mySocket.neighbor_table.update_neighbor(src_ip, src_port)&#10;    #print(f&quot;[HEARTBEAT] Received from {src_ip}:{src_port}&quot;)&#10;&#10;# =========================================================&#10;# Handling received ROUTING_UPDATE&#10;# =========================================================&#10;&#10;&#10;def handle_routing_update(mySocket, data, on_routing_update=None):&#10;    #TODO&#10;    print(&quot;handle_routing_update&quot;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/customSocket/send_handlers/routing_update_handler.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/customSocket/send_handlers/routing_update_handler.py" />
              <option name="originalContent" value="import ipaddress&#10;&#10;from customSocket import config, byteEncoder&#10;from customSocket.helpers.models import RoutingUpdatePayload, RoutingUpdateEntry, RoutingUpdateMessage, Header&#10;&#10;&#10;def send_routing_update(mySocket):&#10;    &quot;&quot;&quot;&#10;    Sendet Routing Updates an alle lebenden Nachbarn.&#10;    &#10;    Implementiert:&#10;    1. Split Horizon: Routen werden NICHT an den Next-Hop zurückgesendet&#10;    2. Poison Reverse: Tote Nachbarn werden mit Distance 255 markiert&#10;    &quot;&quot;&quot;&#10;    # Hole alle lebenden Nachbarn&#10;    alive_neighbors = mySocket.neighbor_table.get_alive_neighbors()&#10;    &#10;    if not alive_neighbors:&#10;        print(&quot;[INFO] No alive neighbors to send routing update to&quot;)&#10;        return&#10;    &#10;    # Hole alle Routen aus der Routing-Tabelle&#10;    # Format: [(dest_ip, dest_port, distance), ...]&#10;    routing_entries = mySocket.routing_table.export_for_update()&#10;    &#10;    # Für jeden lebenden Nachbarn ein individuelles Update senden&#10;    for neighbor in alive_neighbors:&#10;        neighbor_ip = neighbor.ip&#10;        neighbor_port = neighbor.port&#10;        &#10;        # Erstelle Liste der Einträge mit Split Horizon&#10;        entries_for_neighbor = []&#10;        &#10;        for dest_ip, dest_port, distance in routing_entries:&#10;            # Hole die vollständige Route aus der Routing-Tabelle&#10;            route = mySocket.routing_table.get_route(dest_ip, dest_port)&#10;            &#10;            if route is None:&#10;                continue&#10;            &#10;            # Split Horizon: Sende keine Route zurück zum Next-Hop&#10;            # Wenn der Next-Hop dieses Nachbarn ist, überspringe diese Route komplett&#10;            if route.next_hop_ip == neighbor_ip and route.next_hop_port == neighbor_port:&#10;                continue  # Route wird NICHT gesendet (Split Horizon)&#10;            &#10;            # Prüfe ob das Ziel ein toter Nachbar ist&#10;            is_dest_dead = not mySocket.neighbor_table.is_alive(dest_ip, dest_port)&#10;            &#10;            if is_dest_dead:&#10;                # Poison Reverse: Tote Nachbarn mit Distance 255 markieren&#10;                entries_for_neighbor.append(&#10;                    RoutingUpdateEntry(&#10;                        dest_ip=dest_ip,&#10;                        dest_port=dest_port,&#10;                        distance=255  # Poison für tote Nachbarn&#10;                    )&#10;                )&#10;            else:&#10;                # Normale Route senden&#10;                entries_for_neighbor.append(&#10;                    RoutingUpdateEntry(&#10;                        dest_ip=dest_ip,&#10;                        dest_port=dest_port,&#10;                        distance=distance&#10;                    )&#10;                )&#10;        &#10;        # Wenn keine Einträge vorhanden sind, trotzdem ein leeres Update senden&#10;        # (damit Nachbarn wissen, dass wir noch leben)&#10;        &#10;        # Erstelle die Payload&#10;        payload = RoutingUpdatePayload(entries=entries_for_neighbor)&#10;        &#10;        # Berechne Payload-Länge: 2 Bytes (entry count) + (7 Bytes pro Eintrag)&#10;        payload_length = 2 + (len(entries_for_neighbor) * 7)&#10;        &#10;        # Hole neue Sequenznummer&#10;        seq_num = mySocket.get_seq_num()&#10;        &#10;        # Erstelle die Nachricht&#10;        update_msg = RoutingUpdateMessage(&#10;            header=Header(&#10;                type=9,  # ROUTING_UPDATE&#10;                sequence_number=seq_num,&#10;                destination_ip=neighbor_ip,&#10;                source_ip=int(ipaddress.IPv4Address(mySocket.my_ip_str)),&#10;                destination_port=neighbor_port,&#10;                source_port=mySocket.my_port,&#10;                payload_length=payload_length,&#10;                chunk_id=0,&#10;                chunk_length=0,&#10;                ttl=config.TTL_DEFAULT,&#10;                checksum=bytes(32)&#10;            ),&#10;            payload=payload&#10;        )&#10;        &#10;        # Encodiere und sende&#10;        encoded_data = byteEncoder.encodePayload(update_msg)&#10;        mySocket.send_queue.put((&#10;            encoded_data, &#10;            (str(ipaddress.IPv4Address(neighbor_ip)), neighbor_port)&#10;        ))&#10;        &#10;        print(f&quot;[SENT] Routing Update to {ipaddress.IPv4Address(neighbor_ip)}:{neighbor_port} &quot;&#10;              f&quot;with {len(entries_for_neighbor)} entries&quot;)&#10;    &#10;    return&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="import ipaddress&#10;&#10;from customSocket import config, byteEncoder&#10;from customSocket.helpers.models import RoutingUpdatePayload, RoutingUpdateEntry, RoutingUpdateMessage, Header&#10;&#10;&#10;def send_routing_update(mySocket):&#10;    &quot;&quot;&quot;&#10;    Sendet Routing Updates an alle lebenden Nachbarn.&#10;    &#10;    Implementiert:&#10;    1. Split Horizon: Routen werden NICHT an den Next-Hop zurückgesendet&#10;    2. Poison Reverse: Tote Nachbarn werden mit Distance 255 markiert&#10;    &quot;&quot;&quot;&#10;    # Hole alle lebenden Nachbarn&#10;    alive_neighbors = mySocket.neighbor_table.get_alive_neighbors()&#10;    &#10;    if not alive_neighbors:&#10;        print(&quot;[INFO] No alive neighbors to send routing update to&quot;)&#10;        return&#10;    &#10;    # Hole alle Routen aus der Routing-Tabelle&#10;    # Format: [(dest_ip, dest_port, distance), ...]&#10;    routing_entries = mySocket.routing_table.export_for_update()&#10;    &#10;    # Für jeden lebenden Nachbarn ein individuelles Update senden&#10;    for neighbor in alive_neighbors:&#10;        neighbor_ip = neighbor.ip&#10;        neighbor_port = neighbor.port&#10;        &#10;        # Erstelle Liste der Einträge mit Split Horizon&#10;        entries_for_neighbor = []&#10;        &#10;        for dest_ip, dest_port, distance in routing_entries:&#10;            # Hole die vollständige Route aus der Routing-Tabelle&#10;            route = mySocket.routing_table.get_route(dest_ip, dest_port)&#10;            &#10;            if route is None:&#10;                continue&#10;            &#10;            # Split Horizon: Sende keine Route zurück zum Next-Hop&#10;            # Wenn der Next-Hop dieses Nachbarn ist, überspringe diese Route komplett&#10;            if route.next_hop_ip == neighbor_ip and route.next_hop_port == neighbor_port:&#10;                continue  # Route wird NICHT gesendet (Split Horizon)&#10;            &#10;            # Prüfe ob das Ziel ein toter Nachbar ist&#10;            is_dest_dead = not mySocket.neighbor_table.is_alive(dest_ip, dest_port)&#10;            &#10;            if is_dest_dead:&#10;                # Poison Reverse: Tote Nachbarn mit Distance 255 markieren&#10;                entries_for_neighbor.append(&#10;                    RoutingUpdateEntry(&#10;                        dest_ip=dest_ip,&#10;                        dest_port=dest_port,&#10;                        distance=255  # Poison für tote Nachbarn&#10;                    )&#10;                )&#10;            else:&#10;                # Normale Route senden&#10;                entries_for_neighbor.append(&#10;                    RoutingUpdateEntry(&#10;                        dest_ip=dest_ip,&#10;                        dest_port=dest_port,&#10;                        distance=distance&#10;                    )&#10;                )&#10;        &#10;        # Wenn keine Einträge vorhanden sind, trotzdem ein leeres Update senden&#10;        # (damit Nachbarn wissen, dass wir noch leben)&#10;        &#10;        # Erstelle die Payload&#10;        payload = RoutingUpdatePayload(entries=entries_for_neighbor)&#10;        &#10;        # Berechne Payload-Länge: 2 Bytes (entry count) + (7 Bytes pro Eintrag)&#10;        payload_length = 2 + (len(entries_for_neighbor) * 7)&#10;        &#10;        # Hole neue Sequenznummer&#10;        seq_num = mySocket.get_seq_num()&#10;        &#10;        # Erstelle die Nachricht&#10;        update_msg = RoutingUpdateMessage(&#10;            header=Header(&#10;                type=9,  # ROUTING_UPDATE&#10;                sequence_number=seq_num,&#10;                destination_ip=neighbor_ip,&#10;                source_ip=int(ipaddress.IPv4Address(mySocket.my_ip_str)),&#10;                destination_port=neighbor_port,&#10;                source_port=mySocket.my_port,&#10;                payload_length=payload_length,&#10;                chunk_id=0,&#10;                chunk_length=0,&#10;                ttl=config.TTL_DEFAULT,&#10;                checksum=bytes(32)&#10;            ),&#10;            payload=payload&#10;        )&#10;        &#10;        # Encodiere und sende&#10;        encoded_data = byteEncoder.encodePayload(update_msg)&#10;        mySocket.send_queue.put((&#10;            encoded_data, &#10;            (str(ipaddress.IPv4Address(neighbor_ip)), neighbor_port)&#10;        ))&#10;        &#10;        print(f&quot;[SENT] Routing Update to {ipaddress.IPv4Address(neighbor_ip)}:{neighbor_port} &quot;&#10;              f&quot;with {len(entries_for_neighbor)} entries&quot;)&#10;    &#10;    return&#10;&#10;&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>